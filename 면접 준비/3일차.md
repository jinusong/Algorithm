# 3일차
## 스레드와 스레드 핸들러
### 스레드간 통신 방법
* Handler를 이용
* 두 개 이상의 스레드를 사용할 때의 동기화 이슈를 차단하기 위해 Looper와 Handler를 사용.
### Handler
* Handler는 Looper로부터 받은 Message를 실행, 처리하거나 다른 스레드로부터 메시지를 받아서 MessageQueue에 넣는 역할을 하는 스레드 간의 통신장치이다.
* 일반적으로 UI 갱신을 위해 사용. (뷰나 뷰그룹에서 제공하는 메소드는 단일 스레드 모델 Thread-Unsafe)
* 핸들러는 두 종류의 객체를 메시지 큐(Message Queue)를 통해 특정 스레드로 전달한다.
* 문자와 필드로 구성된 메시지 객체 & Runnable 객체

### Looper
* Looper는 무한히 루프를 돌며 자신이 속한 스레드의 Message Queue에서 Message나 Runnable 객체를 차례로 꺼내 Handler가 처리하도록 전달한다.
* 메인 스레드에는 Looper가 기본적으로 생성되어 있지만, 새로 생성한 스레드는 Looper를 가지고 있지 않기 때문에 메시지를 받을 수 없다.
* 사용할 수 있는 메시지 큐가 없기 때문이다.
* 서브 스레드에서 메시지를 전달받기 위해서는 Looper를 생성해주어야 함.
* 하지만 Looper 자동 보유클래스 -> HandlerThread

## JetPack AAC
### AAC를 왜 만들었지?
* 안드로이드는 Activity, BroadCastReceiver, Service, ContentProvider 등 여러 컴포넌트들이 있고, 생명주기가 다르게 얽혀있다.
* 앱을 잘 만들기 위해서는 이러한 컴포넌트들을 부드럽게 연결해야하는데 생명주기를 학습하고 엉키지 않도록 고민하는 것은 결국 개발자의 몫이었다.
* 구글은 이 고민을 줄이기 위해 SDK에서 제공하는 컴포넌트들에 대해 개발자들에게 더 가이드를 주기를 원헀다.
* 그래서 Android Architecture Components(AAC)가 만들어졌다.

### Lifecycles
* Lifecycles는 라이브러리 이름답게 생명주기 모니터링을 돕습니다.
* 크게 2가지로 구성되어 있다.

* **Lifecycle Owner**: 자신의 생명주기를 Lifecycle 객체가 Lifecycle Owner이다.
* **Lifecycle Observer**: LifecycleObserver를 구현한 클래스는 onResume() 등의 생명주기 메소드를 정의할 수 있다. 이 메소드들은 등록한 Lifecycle Owner가 해당 생명주기 상태가 되면 자동으로 수행되면서 객체가 화면과 동일한 생명주기를 가진 것처럼 행동하도록 한다.

### LiveData
* LiveData는 데이터를 개선된 Observable로 Wrapping하여 생명주기와 데이터 변경을 인지할 수 있도록 한다.

### ViewModel
* AAC의 뷰모델은 데이터를 쉽게 생명주기와 분리하여 관리할 수 있도록 돕는다.
* AAC의 ViewModel을 상속받은 뷰모델은 ViewModelProviders로 Scope를 관리할 수 있다.
* 해당 Scope내에서는 하나의 인스턴스만을 유지하여 작업이 중복되거나 데이터가 소실되지 않도록 한다.
* Activity를 Scope로 하면 Fragment간에도 하난의 뷰모델을 공유하여 데이터를 전달할 수 있다.

### Room
* ORM은 Cursor단위로 통신하는 쿼리를 객체 단위로 통신할 수 있도록 돕는다.
* Room은 이러한 ORM 라이브러리 중 하나로, Annotation 기반이다.
* 적절한 Annotation으로 쉽게 데이터베이스, 테이블, DAO 등을 정의할 수 있다.
* 세부 내용도 Annotation을 이용해 약간의 Room 규약에 맞게 선언해주면, Primary key, 쿼리 파리미터, 반환 타입 등 자동으로 많은 것을 매칭해준다.
* 컴파일 타임에 쿼리를 검증해줘서 정확한 쿼리 작성 가능

### DataBinding
* 프로그래매틱 방식이 아니라 선언적 형식으로 레이아웃의 UI 구성요소를 앱의 데이터 소스와 결합할 수 있는 지원 라이브러리이다.

### WorkManager
* 시스템 기반의 백그라운드 프로세싱 API를 제공하여, 구현을 단순화하도록 도와준다
* 앱이 포그라운드에 없어도 백그라운드 Job에서 작업들이 수행되도록 하고, jobScheduler나 Firebase의 jobDispatcher를 사용할 수 있다면 사용한다.
* 앱이 포그라운드라면 그 프로세스에 가급적 처리할 수 있도록 하여 개발자가 백그라운드 처리과정을 깊게 고민하지 않아도 된다.

* Worker라는 클래스를 상속받아 구현하고 doWork()라는 함수에 실행할 동작을 정의한다.
* 그리고 WorkManager를 호출해 Worker를 실행하고 가장 최적의 스케줄을 선택하여 작업을 큐에 추가한다.
* 작업의 결과는 LiveData를 이용해 구독할 수 있고, 해당 작업의 산출물은 Data로 이용할 수 있다.

### Paging
* 많은 데이터를 List 형식으로 불러올때 점진적으로 로드하기 위해서 만들어진 컴포넌트
* 공부는 했었지만 구현한적이 없어서 아직 잘모른다.

## Controller와 Presenter의 차이
* Controller에서는 여러 View를 관장할 수 있지만 Presenter는 각 View마다 Presenter가 할당된다.
* Controller에서 user event를 처리하지만, Presenter는 View에서 user event를 받는다.
* Controller에서는 user event에 따른 데이터 로직을 수행하지만 MVP에서의 View는 user event를 Presenter로 전달할 뿐이다.

## Databinding을 쓰는 이유
* 원래 안드로이드는 xml에 데이터가 저장되는 형태로 어플리케이션 코드에서는 그 xml의 데이터를 가져와 사용하는 정적 데이터 사용방식이었는데 Databinding을 사용하면 데이터가 동적으로 바뀌기 때문에 여러 개로 나뉘었던 프로젝트 로직이 하나로 통합.

## Dagger2 static 사용하는 경우
* 일반적으로 @Provides 메서드는 매번 새 인스턴스를 반환하며 Dagger는 인스턴스를 저장하거나 캐시하지 않는다.
* 일단 Singleton과 static을 구분해야한다.
* Provides 메서드에 Singleton을 붙이면 프로그램이 돌아가는 동안 인스턴스는 한번만 만들어진다. 이 것은 곧 메소드를 한번 호출하고 결과를 저장하라는 의미가 된다.
* 그리고 static을 사용하면 컴포넌트 구현에서 Dagger는 자동으로 메소드를 정적으로 호출한다. 이 과정에서 VM은 인스턴스 상태를 고려하지 않아도 때문에 안드로이드 내에서 성능이 높아진다.

## Java

### **1. 객체와 클래스 차이점**

* **클래스는 객체를 생성하기 위한 설계도 또는 틀**이라고 볼 수 있고, **객체는 설계도 또는 틀로 찍어낸 실체**라고 볼 수 있다. 
* 객체를 클래스의 인스턴스라고도 부르며 객체와 인스턴스 두 용어를 구별없이 사용한다.

* **클래스는 객체들이 어떤 특성을 갖는다고 정의만**하고 값은 가질 수 없으나 **객체는 실존하며 각각 자신만의 고유한 속성 값**을 갖는다.

### **2. 자바 기본형과 wrapper 클래스 차이점**

* 8개의 기본 데이터를 객체 형식으로 다루기위해 JDK에 의해 지원되는 8개의 클래스(Byte, Short, Integer, Long, Character, Double, Float, Boolean)를 통칭하여 Wrapper 클래스라고 말한다.

* int, double 등 자바 기본 데이터 타입은 클래스가 아니다. 따라서 기본 데이터 값도 객체가 아니다.

### **3. 자바 컬렉션 종류와 차이점**

* Set : 중복X, 순서X
* List : 중복허용, 순서 유지

* 컬렉션은 가변 크기로서 객체의 개수를 염려할 필요가 없다. 
* 컬렉션 내의 한 객체가 삭제되면 컬렉션이 자동으로 자리를 옮겨준다.

* Vector : List 인터페이스를 구현한 클래스. 가변 개수의 배열이 필요할 때 적합. 
* 벡터에 삽입되는 요소의 수가 많아지면 자동으로 크기가 조절됨. 요소는 벡터의 맨 마지막이나 중간에 삽입될 수 있다. 
* 이 경우 벡터는 삽입되는 요소의 뒤에 있는 모든 요소들을 한 자리씩 뒤로 이동시킨다.

* 무조건 동기화 -> 성능이 많이 떨어짐, 쓸일이 별로 없어짐 왜냐면 동기화 처리가 필요할 때 Collection, synchronizedCollection, synchronizedList,Map 등을 이용하는게 성능적으로 더 좋음.

* ArrayList : Vector클래스와 거의 동일. 크게 다른 점은 ArrayList는 스레드 간에 동기화를 지원하지 않기 때문에, 
* 다수의 스레드가 동시에 요소를 삽입하거나 삭제할 때 충돌이 발생할 수 있다. ArrayList를 이용하려면 멀티스레드의 동기화를 직접 구현해야 한다.

* HashMap<K,V> : 키, 값의 쌍으로 구성되는 요소를 다룸.

* LinkedList : List 인터페이스를 구현한 클래스. 요소들을 양방향으로 연결하여 관리한다는 점을 제외하고 Vector, ArrayList와 매우 유사. 
* LinkedList는 맨 앞과 맨 뒤를 가리키는 head,tail, 레퍼런스를 가지고 있어, 맨 앞이나 맨 뒤, 중간에 요소의 삽입이 가능하며 인덱스를 이용하여 요소에 접근할 수도 있음.

### **4. equals VS. == 연산자 차이점**

* **equals** : 문자열 자체를 비교

* **== 연산자** : 객체의 주소값을 비교

* ### **4-1. 위 코드의 결과를 예상**

~~~java
String s1 = "abc";

String s2 = new String("abc");

s1 == s2;

false.
~~~

* 이유는?

* String s1 = “123”은 **String Pool에서 관리** 된다. 따라서 두 개의 문자열 변수를 지정했지만 Jvm Heap 메모리의 String Pool에는“Hello”라는 문자열 하나만 존재한다.

* **new 키워드**를 사용한 두번째 문장은, **Heap에 객체를 생성**하게 된다.

* 같은 객체를 참조하는것이 아니기 때문에 결과가 false가 된다. (==연산자는객체의 주소값을 비교)

### **4-2. 위 연산을 true로 만들려면 어떻게 해야 할까?**

1. **s1.equals(s2)** 는 문자열 자체를 비교한 결과를 돌려받기 때문에 -> true
2. **s2.intern()** 메서드를 이용하면 String pool에 등록할 수 있다. -> true

### **5. 추상화란?**

* **어떤 객체를 표현함에 있어** 모든 것을 다 표현하는 것이 아니라 **일정 부분 특징만을 표현**. 
* 추상화를 하게 되면 목적을 위해 필요한 부분만을 찾을 수 있다. **(공통된 개념과 관계에 집중할 수 있게 됨)**

### **6. 추상클래스란?**

1. 추상 메소드(선언은되어있으나 코드 구현X, 껍데기만 있는)를 포함하는 클래스(abstract로 선언)
2. 추상메소드가 하나도 없지만 abstract로 선언한 클래스

### **6-1. 추상클래스의 용도**

* 추상클래스를 상속받은 서브 클래스는 개발자에 따라 다양하게 구현 (하지만 모든 개발자들이 서브 클래스에서 추상 클래스에 선언된 추상 메소드를 모두 구현해야 한다)

* 추상클래스를 책의 목차에 비유하면, 서브 클래스는 콕차에 따라 작성된실제 책과 같다.

* 추상 클래스를 이용하면 응용프로그램의 설계와 구현을 분리할 수 있다.

* 추상 클래스로 기본 방향을 잡아놓고 서브 클래스에서 구현하면 구현 작업에 쉬워진다. 
* 또한, 추상 클래스는 계층적 상속 관계를 가지는 클래스들의 구조를만들 때 적합하다.

### **7. 인터페이스란?**

1. 자바의 인터페이스는 추상 클래스와 유사.
2. 인터페이스는 규격과 같은 것.(따라서 인터페이스에 수정을 가할 때는 기존 인터페이스를 상속받아 새로운 인터페이스를 만듬. 자바에서 클래스의 다중상속X, 인터페이스 다중상속O)
3. 멤버는 추상메소드(publicabstract), 상수(public static final) 만으로 구성
4. 모든 메소드는 public이며 생략 가능
5. 객체 생성X
6. 다른 인터페이스 상속O (인터페이스는다른 인터페이스를 상속O)
7. 인터페이스 구현 : 인터페이스의추상 메소드를 클래스에서 구현하는 것. (implements 키워드) 이때 클래스는반드시 인터페이스의 모든 추상메소드를 구현해야 함.
8. 인터페이스왜 사용?: 사용될클래스가 어떠한 메소드,멤버들을 갖고 있는가에 대한 명세서와 같은 역할.

    ​

### **8. 추상클래스 VS. 인터페이스 차이점**
* 모든 자식 클래스에 공통된 메소드가 있는 경우에는 추상 클래스가 적합
* 다중 상속 지원

### **9. String Mutable 이란?**

* **Immutable(가변) 객체** : 객체 내의 특정요소를 변경 할 수 있는 객체 (Ex. List,ArrayList, HashMap)

* **Mutable(불변) 객체** : 객체 내의 특정 요소의 값을 변경 할 수 없는 객체 (Ex. String,Integer, Double, Long)

* Set 메소드 X, heap 영역에서 변경불가라는 뜻(String a=”a”; a=”b” 와 같은 재할당은 가능)

### **9-1. StringBuffer vs. String**
* StringBuffer는 Mutable

### **10. String Pool이 위치하는 영역은?**
* Heap 영역.
* Perm 영역에서 Java7에서Heap으로 바뀜 -> 이점 : String pool의 모든 문자열도 GC의 대상이 될 수 있음.
* 가비지 컬렉션(Garbage Collection)