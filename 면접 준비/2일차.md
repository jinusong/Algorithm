# 2일차
## 안드로이드 아키텍처
### 안드로이드 소프트웨어 스택
* 안드로이드 시스템은 소프트웨어 스택의 형태로 구성합니다.
* 어플리케이션, 운영체제, 런타임 환경, 미들웨어, 각종 서비스와 라이브러리 등이 겹겹이 모여 구성합니다.
* ![안드로이드 아키텍처](https://t1.daumcdn.net/cfile/tistory/990A5A335995893302)
* **리눅스 커널**: 스택의 맨밑. 장치 하드웨어의 기반 운영체제 역할을 담당합니다. 안드로이드는 리눅스의 커널만 사용합니다. 리눅스의 커널의 효율성과 성능이 좋으므로 안드로이드 소프트웨어 스택의 핵심으로 모바일 장치에서도 사용합니다.
* **안드로이드 런타임(ART)**: 안드로이드 어플리케이션이 빌드될 때는 바이트 코드형태로 컴파일됩니다. 장치에 어플리케이션이 설치될 때 안드로이드 런타임이 AOT(Ahead Of  Time) 컴파일을 행하여 바이트 코드를 기계어로 번역합니다. 이렇게 변환된 형태를 ELF라고 합니다. ELF 버전으로 실행되므로 어플리케이션의 실행속도가 더 빠르고 배터리 수명도 향상됩니다.

### 안드로이드 라이브러리 종류
* **android.app**: 어플리엨이션 모델의 액세스를 제공하며, 모든 안드로이드 어플리케이션의 초석이 되는 라이브러리입니다.
* **android.content**: 어플리케이션과 어플리케이션 컴포넌트 간의 콘텐트 액세스와 메세징을 가능하게 입니다.
* **android.database**: 콘텐트 제공자가 게시한 데이터를 액세스하는데 사용되고, SQLite 데이터베이스 관리 클래스를 포함합니다.
* **android.graphics**: 생삭, 포인트, 필터, 사각형, 캔버스를 포함하는 낮은 수준의 2D 그래픽 드로잉 API입니다.
* **android.hardware**: 가속도 센서와 광센서 같은 하드웨어의 액세스를 제공하는 API를 나타냅니다.
* **android.opengl** - OpenGL ES 3D 그래픽 렌더링 API의 자바 인터페이스입니다.
* **android.os** - 메세지, 시스템 서비스, 프로세스 간 통신을 포함하는 표준 운영체제 서비스의 액세스를 애플리케이션에 제공합니다.
* **android.media** - 오디오와 비디오의 재생을 할 수 있는 클래스 제공합니다.
* **android.net** - 네트워크 액세스를 제공하는 API. 장치의 문서 네트워크 액세스를 제공하는 android.net.wifi를 포함합니다.
* **android.print** - 안드로이드 애플리케이션에서 프린터로 콘텐트를 전송할 수 있는 클래스들을 포함합니다.
* **android.provider** - 캘린더나 연락처 애플리케이션에서 유지하는 것과 같은 표준 안드로이드 콘텐트 제공자 데이터베이스의 액세를 제공하는 클래스들이 있습니다.
* **android.text** - 장치 화면에 텍스트를 나타내고 처리하는 데 사용합니다.
* **android.util** - 문자열과 숫자 변환, XML 처리, 날짜와 시간 처리 등의 일을 수행하는 유틸리티 클래스들이 있습니다.
* **android.view** - 애플리케이션의 사용자 인터페이스를 구성하는 뷰 클래스들이 있습니다.
* **android.widget** - 버튼, 라벨, 리스트 뷰, 레이아웃 매니저, 라디오 버튼과 같은 같은 사전 제각된 사용자 인터페이스 컴포넌트들이 있습니다.
* **android.webkit** - 웹 브라우징 능력을 애플리케이션에 구성할 수 있게 해주는 클래스들이 있습니다.

### 안드로이드 인텐트

* 인텐트는 하나의 액티비티가 다른 액티비티를 시작시킬 수 있는 메커니즘.
* 한 액티비티가 다른 액티비티를 직접 시작 시키는 것이 아님.
* 액티비티가 안드로이드 런타임에 인텐트를 요청하면 그 인텐트에 부합되는 액티비티를 안드로이드 런타임에서 찾아 시작시킴.
* 인텐트에서는 수행될 오퍼레이션를 나타내고, 필요하다면 전달할 데이터도 포함시킬 수 있음.

**명시적 인텐트**
* 클래스의 이름으로 액티비티를 참조하여 특정 액티비티의 시작을 안드로이드 런타임에 요청. 때문에 시작할 액티비티를 우리가 정확하게 알고 있어야함. 
* 특정 컴포넌트나 액티비티가 명확하게 실행되어야할 경우에 사용

**암시적 인텐트**
* 우리가 하길 원하는 작업을 안드로이드 런타임에 알려줌. 
* 그러면 그런 작업을 할 수 있다고 자신을 등록한 액티비티를 안드로이드 런타임이 찾아서 시작.
* 그런 능력의 액티비티를 하나 이상 찾을 경우는 사용자가 선택할 수 있게함.
* 이미 기존에 어떤 기능들을 지원하는 앱들이 있는 경우에 암시적 인텐트를 사용해서 그 앱들을 사용하면 됩니다.

### 브로드캐스트 인텐트

* 브로드캐스트 수신자(Broadcast Receiver)로 등록된 모든 애플리케이션에 전송되는 시스템 차원의 인텐트. 
* 브로드캐스트 인텐트는 일반적인 인텐트와 유사하지만, 지정된 컴포넌트만 인텐트를 받는것이 아닌 시스템의 여러 컴포넌트가 동시에 받을 수 있다는 차이가 있음.

**정규 브로드캐스트 인텐트**
* 관련 이벤트에 관심 있는 모든 브로드캐스트 수신자에게 비동기 형태로 동시에 전송됨.

**순차 브로드캐스트 인텐트**
* 한 번에 하나의 브로드캐스트 수신자에게 전송됨.
* 그리고 그다음 차례의 브로드캐스트 수신자에게 계속 전송되거나 또는 중단될 수 있음.

### 브로드캐스트 수신자(BroadCast Revciever)

* 애플리케이션이 브로드캐스트 인텐트에 응답할 수 있는 메커니즘.
* 브로드캐스트 수신자는 애플리케이션에 등록해야함. 
* 관심 있는 브로드캐스트 타입을 나타내는 인텐트 필터(Intent Filter)를 사용해서 구성.
* 그리고 등록된 브로드캐스트 타입이 인텐트와 일치하면 안드로이드 런타임이 그 수신자를 시작시킴. (수신자를 등록한 애플리케이션의 현재 실행 여부와 무관하게)

* 그다음에 그 수신자는 필요한 작업을 5초 이내에 수행하고 복귀해야 함.
* 브로드캐스트 수신자는 백그라운드로 실행되며 사용자 인터페이스를 갖지 않음.

### 콘텐트 제공자(Content Provider)

* 애플리케이션 간에 데이터를 공유하는 메커니즘을 구현함.
* 어떤 어플리케이션도 자신의 내부 데이터에 대한 액세스를 다른 애플리케이션에게 제공할 수 있음.
* 이때 그 데이터를 추가, 삭제, 조회하는 능력을 갖는 콘텐트 제공자를 구현.
* 그리고 데이터의 액세스는 콘텐트 제공자가 정의한 URI를 통해 제공.

* 안드로이드 시스템에서 현재 사용 가능한 콘텐트 제공자는 콘텐트 리서버(Content Resolver)를 사용해서 찾을 수 있음.

### 안드로이드 서비스(Service)

* 백그라운드 실행되는 프로세스이며, 사용자 인터페이스를 갖지 않음.
* 서비스가 시작된 후에는 액티비티나 브로드캐스트 수신자 및 그 외 다른 서비스로부터 관리됨.

* 서비스는 안드로이드 런타임에 의해 다른 프로세스보다 더 높은 우선순위로 실행됨.
* 장치의 메모리 부족 등으로 리소스를 해제하다가 어쩔 수 없는 경우에 마지막 수단으로 종료됨.
* 그러나 리소스가 다시 사용 가능하게 되면 그 즉시 자동으로 다시 시작됨.

* 서비스는 포그라운드에서 실행될 필요가 있다고 선언함으로써 중단의 위험을 줄일 수 있음.
startForeground()을 호출하면 됨.

* 더 자세한건 예제 파일에 ForegroundServiceExample을 참고할 것

### 애플리케이션 매니페스트

* 앱을 구성하는 다양한 요소를 합치는 접착제의 역할을 하는 것.
* XML 파일이며, 애플리케이션에 관련된 액티비티, 서비스, 브로드캐스트 수신자, 데이터 제공자, 퍼미션 등이 정의되어 있음. 

* 이 정보들은 안드로이드 런타임에서 참조하고 사용.

### 애플리케이션 리소스

* 안드로이드 애플리케이션은 애플리케이션 패키지(APK)로 빌드되어 장치에 설치 및 실행됨.
* 이떄 APK에는 자바 실행 코드(dex 파일), 매니페스트 파일의 메타 데이터, 각종 리소스 파일들이 포함됨.

* 그리고 리소스 파일에는 여러 종류의 리소스가 포함됨.
* XML로 정의된 사용자 인터페이스 레이아웃과 함께 사용자 인터페이스에 나타나는 문자열, 이미지, 폰트와 색상 등이 있음.

* 리소스 파일들이 프로젝트 디렉터리 아래의 app/src/main/res 서브 디렉터리에 저장됨.

### 애플리케이션 컨텍스트

* 애플리케이션이 컴파일되면 애플리케이션의 모든 리소스에 대한 참조를 포함하는 R 이라는 이름의 클래스가 자동 생성됨.
* 그리고 애플리케이션의 매니페스트 파일과 그런 리소스들이 결합되어 애플리케이션 컨텍스트(Application Context)가 생성됨.

* 컨텍스트는 안드로이드 Context 클래스로 나타내며, 런타임 시에 애플리케이션의 리소스를 액세스하기 위해 애플리케이션 코드에서 사용될 수 있음. 

* 또한, 런타임 시의 정보를 수집하고 애플리케이션의 환경을 변경하기 위해 애플리케이션의 컨텍스트에서 여러 가지 메서드들이 호출될 수 있음.

### 안드로이드 애플리케이션과 리소스 관리

* 안드로이드 5.0 롤리팝 이전에는 안드로이드 애플리케이션이 달빅 가상 머신(Dalvik Virtual Machine)의 인스턴스에 실행되고, 각 가상 머신은 운영체제(리눅스)의 별개 프로세스로 실행됨. 
* 그러나 그 이후 안드로이드 버젼 부터는 가상 머신이 없어지고 안드로이드 런타임(ART)시스템의 통제하에 리눅스 프로세스로 실행됨. 
* 만약 장치의 리소스(특히 메모리)가 한계에 도달하면 안드로이드 시스템에서 메모리를 해제하기 위해 프로세스들을 중단시키는 조치를 취함.

* 메모리 헤제를 위해 어떤 프로세스를 중단시킬지 결정할 때 시스템에서 현재 실행 중인 모든 프로세스들의 우선순위(priority)와 상태(state) 모두 고려함. 
* 이때, 그런 요소들을 결합하여 구글에서 이야기하는 중요도 서열(importance hierarchy)이라는 것을 생성함. 
* 그 다음에 가장 낮은 순위의 프로세들부터 중단을 시작해서 시스템이 기능을 수행하는 데 충분한 리소스가 해제될 때까지 작업을 반복.

### 안드로이드 프로세스 상태

* 애플리케이션은 프로세스로 실행되고 컴포넌트로 구성됨.
* 안드로이드 시스템에서 프로세스의 현재 상태는 애플리케이션 내부에서 실행중인 컴포넌트(액티비티나 서비스 등의) 우선순위에 의해 결정됨.

![안드로이드 프로세스 상태](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/98b35236-2025-425a-95f2-db0af78d7539/Untitled.png)

* 위에 그림 처럼 어떤 시점에서든 프로세스는 다음 다섯 가지 중 하나의 상태가 될 수 있음.

**포그라운드 프로세스**: 이 프로세스는 가장 높은 수준의 우선순위가 지정됨. 프로세스가 포그라운드(foreground)상태로 되려면 밑의 조건을 하나 이상 충족해야 함.

* 사용자와 현재 상호작용 중인 액티비티를 호스팅(포함해서 실행)한다.
* 사용자와 현재 상호작용 중인 액티비티에 연결된 서비스를 호스팅한다.
* 중단되면 사용자에게 해를 끼칠 수 있다는 것을 startForeground() 메서드를 호출하여 알려준 서비스를 호스팅한다.
* 자신의 onCreate(), onResume(), onStart() 콜백 메서드 중 하나를 실행하는 서비스를 호스팅한다.
* onReceive() 메서드로 현재 실행 중인 브로드캐스트 수신자를 호스팅한다.

**가시적 프로스세스**: 화면적으로 볼 수 있는 있지만 사용자와 상호작용은 하지 않는 액티비티를 포함하는 프로세스는 가시적 프로세스(visible process)로 분류. 

* 프로세스의 액티비티를 사용자가 화면에서 볼 수 있지만, 이 액티비티의 화면 일부를 다른 액티비티(예를 들어, Dialog, 카톡 알림)이 포그라운드로 실행하면서 가리는 경우다. 

* 가시적이거나 포그라운드로 실행되는 액티비티와 결부된 서비스를 호스팅하는 프로세스도 가시적 상태가 될 수 있음.

**서비스 프로세스**: 이미 시작되어 현재 실행 중인 서비스(service)를 포함하는 프로세스다.

**백그라운드 프로세스**: 사용자가 화면으로 현재 볼 수 없는 하나 이상의 액티비티를 포함하는 프로세스. 
* 더 높은 우선순위의 프로세스에서 추가 메모리가 필요한 경우, 이 부류의 프로세스는 안드로이드 런타임에 의해 중단될 가능성이 큼. 
* 안드로이드는 백그라운드 프로세스(background process)의 내역을 동적으로 유지 관리하면서 실행 순서에 따라 프로세스를 중단시킴.

* 즉, 포그라운드에서 실행한 프로세스 중 가장 오래된 프로세스가 먼저 종료됨.

**비어 있는 프로세스**
* 비어 있는 프로세스(empty process)는 실행되는 애플리케이션을 포함하지 않으며, 새로 런칭되는 애플리케이션을 호스팅하기 위해 메모리에 남아 있음. 
* 문을 연 채로 엔진을 켜 놓고 승객의 탑승을 기다리는 버스와 유사. 

* 이런 프로세스는 최저 우선순위를 가지며, 리소스 해제 시에 제일 먼저 중단됨.

### 액티비티 생명주기

* 안드로이드 프로세스의 상태는 자신이 호스팅하는 애플리케이션을 구성하는 액티비티와 컴포넌트의 상태에 의해 결정. 
* 그러므로 애플리케이션이 실행되는 동안 액티비티도 서로 다른 상태로 전환된다는 것을 이해하는 것이 중요. 

* 액티비티의 현재 상태는 액티비티 스택(activity stack) 안에서의 위치에 따라 결정됨.

### 액티비티 스택

* 안드로이드 런타임 시스템에서는 장치에서 실행 중인 각 애플리케이션에 대해 
액티비티 스택을 유지 관리함.

![액티비티 스택](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7fb9c93f-79f4-4c05-a81a-b00e6b94cb1d/Untitled.png)

1. 새로운 액티비티가 시작되면 스택의 맨 위로 들어감.
2. 그리고 새로운 액티비티를 포함해서 현재 실행중인 액티비티는 스택의 맨 위에 위치함
3.  그러나 새로운 액티비티가 시작되면 현재의 액티비티는 그 밑으로 들어감 
4. 또한, 현재의 액티비티가 종료되거나 또는 사용자가 Back 버튼을 눌러 이전 액티비티로 돌아갔을 때는 현재의 액티비티가 스택에서 꺼내어짐
5. 만일 시스템의 리소스(메모리 등)가 부족하게 될 경우는 스택의 제일 밑에 있는 액티비티부터 제거됨.

* 액티비티 스택은 후입선출(LIFO. Last-In-First-Out) 스택임. 
즉, 마지막에 스택으로 들어간 항목이 제일 먼저 꺼내어진다.

### 액티비티 상태

* 애플리케이션에서 실행되는 동안 액티비티는 아래와 같이 서로 다른 상태를 거침.

* **실행(Active/Running)**:  액티비티가 액티비티 스택의 맨 위에 있고, 장치 화면에서 볼 수 있는 포그라운드 테스크이며, 사용자와 현재 상호작용하고 있다. 이런 액티비티는 시스템 리소스가 부족할 때에도 거의 중단되지 않는다.
* **일시 중지(Paused)**: 사용자가 화면에서 볼 수 있지만 포커스를 갖고 있지 않는 경우다. 현재 실행 중인 다른 액티비티가 이 액티비티의 화면을 부분적으로 가리고 있기 때문이다.
* **중단(Stopped)**: 액티비티가 사용자에게 보이지 않는다. 장치 화면에서 이 액티비티 화면 전체를 다른 액티비티가 가리고 있을 때다. 일시 중지 액티비티처럼 이 액티비티는 모든 상태와 멤버 데이터를 보존하고 있다. 그러나 시스템 리소스가 부족할 때 중단될 가능성이 높다.
* **소멸(Killed)**: 메모리 해제를 위해 런타임 시스템에 의해 액티비티가 종료되었으며, 액티비티 스택에도 존재하지 않는다. 만일 애플리케이션에서 요청하면 이런 액티비티들은 다시 시작되어야 한다.

### 구성 변경

안드로이드 액티비티의 상태가 변하는 3가지 요인은 아래와 같음. 

- 포그라운드와 백그라운드 간의 액티비티 이동
- 메모리 해제를 위해 런타임 시스템이 액티티비를 종료시키는 것
- 장치 구성의 변경
    - 기본적으로 화면에 나타난 액티비티의 모습(사용자 인터페이스)에 영향을 주는 구성 변경은 액티비티 인스턴스를 소멸시키고 새로 생성되게 만듬.
    - 예를 들어, 
    장치의 방향을 가로에서 세로 또는 세로에서 가로로 회전시킬 때,
     시스템 폰트 설정을 변경할 때 등이 있음.
    - 액티비티가 새로 생성되는 이유는 
    구성 변경은 사용자 인터페이스의 레이아웃과 같은 리소스에 영향을 주므로 영향을 받은 
    액티비티 인스턴스를 소멸시키고 다시 생성하는 것이 
    그런 변경에 응답하는 가장 빠른 방법이기 때문임.

## 액티비티 생애(Activity LifeCycle)

![액티비티 생애](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/71eb4734-ac23-49ec-926a-5ee688543397/Untitled.png)

* 액티비티는 전체(entire), 가시적(visible), 포그라운드(foreground)의 세 가지 생애를 오간다.

* 전체 생애(Entire Lifetime) - 액티비티가 생성될 때 최초 호출되는 onCreate() 메서드 호출과 종결되기 전에 호출되는 onDestory() 호출 사이에액티비티에서 발생하는 모든 것을 나타내는 데 '전체 생애'라는 용어가 사용됨.
* 가시적 생애(Visible Lifetime) - onStart() 와 onStop() 호출 사이의 액티비티 실행 시기. 이 시기 동안 액티비티는 자신을 사용자에게 화면으로 보여줄 수 있음.
* 포그라운드 생애(Foreground Lifetime) - onResume() 메서드 호출과 onPause() 호출 사이의액티비티 실행 시기를 의미함.

### 안드로이드 액티비티 생명주기 메서드

- onCreate(Bundle saveInstanceState)
    1. 액티비티가 최초 생성될 때 호출되며, 반드시 구현해야하는 메서드.
    2. 대부분의 초기화 작업을 하는데 이상적.
    3. 메서드 인자로는 동적 상태 정보를 포함할 수 있는 Bundle 객체가 전달됨.
    4. 그런 동적 상태 정보는 직전에 생성되었다가 소멸된 동일 액티비티의 인스턴스로부터 전달되며, 일반적으로 사용자 인터페이스의 상태와 관련되는 데이터다.
- onRestart()
    1. 액티비티가 런타임 시스템에 의해 이전에 중단되었다가 막 다시 시작될 때 호출됨.
- onStart()
    1. onCreate() 나 onRestart() 메서드가 호출 후 항상 바로 호출됨.
    2. 액티비티의 UI가 곧 사용자에게 보이게 될 것이라고 액티비티에게 알려줌.
    3. 액티비티가 액티비티 스택의 맨 위로 이동할 때,
    이 메서드가 호출된 다음에는 onResume() 이 호출될 것임.
- onResume()
    1. 액티비티가 액티비티 스택의 맨 위에 있으며,
    사용자와 현재 상호 동작하는 액티비티임을 알려준다.
- onPause()
    1. 이 메서드가 호출 다음에는 onResume() 또는 onStop() 메서드 중 하나가 호출됨.
    2. 액티비티가 포그라운드로 돌아가는 경우는 onResume()가 호출됨.
    3. 반대로 액티비티가 사용자가 볼 수 없게 중단되면서 onStop()이 호출됨.
    4. 이 메서드 내부에서는 액티비티에서 필요한 영속적 데이터(콘텐트 제공자, 데이터베이스, 파일에 저장되는 데이터)를 저장하는 일을 해야 함.
    5. 또한 애니메이션과 같이 CPU를 지나치게 사용하는 작업들을 중단해야 함.
- onStop()
    1. 이 메서드가 호출될 때는 액티비티가 더 이상 사용자에게 보이지 않음.
    2. 다음에는 onRestart() 또는 onDestory() 가 호출됨.
    3. 액티비티가 다시 포그라운드로 들어가면 onRestart()가 호출되며,
    액티비티가 종료될 때는 onDestory()가 호출됨.

- onDestroy()
    1. 이 메서드는 액티비티가 막 소멸되려고 하거나 또는 자발적으로 소멸될 때 호출된다.
    2. 액티비티가 자신의 작업을 완료하고 
    3. finish() 메서드를 호출했거나 
    4. 또는 메모리를 해제하거나 
    5. 구성 변경(ex. 장치의 가로/세로 방향 변경)이 생겨서 
    6. 런타임이 액티비티를 종결하기 때문이다.
    7. 그런 액티비티가 종료될 때 항상 onDestory() 메서드가 호출되는 것은 아니라는 것을 알아두자.
- onConfigurationChanged()
    1. 매니페스트 파일의 android:configChanges 속성을 정의하면 장치의 구성 변경이 생길 때 액티비티가 다시 시작되지 않는 대신 이 메서드가 호출됨.
    2. 이때 새로운 장치 구성을 나타내는 Configuration 객체가 메서드에 전달.
    3. 이런 경우에 액티비티에서는 onConigurationChanged() 메서드에서 구성 변경을 
    처리해야 함.
    4. 몰론 android:configChanges 속성에 정의되지 않은 구성 변경이 발생할 때에 메서드가 호출되지 않고 액티비티가 다시 시작된다.

* 액티비티에서 위 메서드를 오버라이딩할 때 기억할 것이 있다.
* OnRestoreInstance() 와 onSaveInstanceState() 두 메서드를 제외한 
* 나머지 메서드에서는 자신의 구현 코드에서 반드시 Activity 슈퍼 클래스의 오버라이딩되는 메서드를 호출해야한다.

### 동적 상태 & 영속적 상태

* 액티비티 생명주기를 관리하는 주 목적은 적시에 액티비티 상태를 저장하거나 복원하기 위해서임.
* 여기서 말하는 상태(state)는 액티비티가 현재 보존하고 있는 데이터와 현재 보이는 UI 데이터(화면에 나타난 뷰 객체의 데이터)를 의미.

**동적 상태(persistent state)**

* 화면에 보이는 사용자 인터페이스. 
* 사용자 인터페이스는 애플리케이션이 실행되는 동안만 보존.

**영속적 상태(dynamic state)**

* 액티비티는 데이터베이스, 콘텐트 제공자, 파일 등에 저장될 필요가 있는 메모리의 데이터를 유지할 수 있는데 그런 상태 정보를 영속적 상태(persistent state)라고 함.

* 이 두 상태의 차이를 알고 있는 것이 중요.
* 왜냐하면 각각 저장되는 방법과 왜 그렇게 하는지에 대한 이유가 다르기 때문.

* 영속적 상태를 저장하는 목적은 데이터 유실을 막기 위해서임.
* 액티비티가 백그라운드 상태로 있을 때는 런타임 시스템이 그 액티비티를 종료시킬 수 있으므로 액티비티의 데이터가 없어 질 수 있음.

### 액티비티 상태 저장하고 복원하기

* 위에 생명주기 메서드와 더불어 액티비티의 동적 상태를 저장하고 복원하기 위해 특별히 만들어진 두 개의 메서드가 있음.

- onRestoreInstanceState(Bundle savedInstanceState)
    1. 상태 정보가 저장되었던 이전 액티비티 인스턴스로 부터 액티비티가 다시 시작되는 경우에 이 메서드는 onStart() 메서드가 호출된 후 곧바로 호출됨.
    2. onCreate() 메서드처럼 이 메서드도 이전 상태 데이터를 포함하는 Bundle 객체를 인자로 받음.
    3. 그리고 onCreate() 와 onStart() 에서 액티비티의 초기화가 수행된 후에 이전 상태 데이터를 복원하는 것이 더 좋을 때 이 메서드가 사용됨.
- onSaveInstanceState(Bundle outState)
    1. 현재의 동적 상태 데이터가 저장될 수 있겠끔 액티비티가 소멸되기 전에 호출됨.
    2. 여기서 동적 상태 데이터는 대개 사용자 인터페이스와 관련된 것들임.
    3. 이 메서드도 Bundle 객체를 인자로 받으며, 저장되어야 하는 상태 데이터를 Bundle 객체에 넣음.
    4. 그후 이 Bundle 객체는 액티비티가 다시 시작될 때 onCreate() 와 onRestoreInstanceState() 메서드에 전달됨.
    5. 동적 상태 데이터가 저장될 필요가 있다는 것을 런타임이 알 경우에만 이 메서드가 호출된다는 것에 유의하자.

### 액티비티가 다시 시작되지 않게 하기

* 매니페스트 파일의 android:configChanges 속성을 사용하면구성 변경이 생기더라도 액티비티가 다시 시작하지 않게 할 수 있음.
* 대신에 onConfigurationChanged() 메서드가 호출됨.

## 안드로이드 프래그먼트 - 295

* 프래그먼트는 액티비티 내부에서 독립적으로 애플리케이션의 UI를 관리하는 객체.

### 프래그먼트 생성
* 아래 처럼 onCreateView 메서드를 오버라이딩 해서 불러움.
* 그리고 onCreateView 메서드와 더불어 프래그먼트의 생명주기 메서드도 오버라이딩 할 수 있음.

### 프래그먼트 생애

**최초 생성 LifeCycle**

1. **onAttatch()** : Fragment가 Activity에 붙을 때 호출
2. **onCreate()** : Activity에서의 oncreate()와 비슷, ui관련 작업X
3. **onCreateView()** : Layout을 inflater하여 View 작업
4. **onActivityCreated()** : Activity에서 Fragment를 모두 생성하고 난 다음 호출, 액티비티의 onCreate()에서 setContentView()한 다음이라고 생각하면 쉽게 이해 될것 같다. 여기서 부터는 ui변경작업이 가능하다.
5. **onStart()**: Fragment가 화면에 표시될때 호출된다. 사용자의 Action과 상호 작용 할 수 없다.
6. **onResume()**: Fragment가 화면에 완전히 그렸으며, 사용자의 Action과 상호 작용이 가능하다.

**다른 Fragment가 add**
1. **onPause()**: Fragment가 사용자의 Action과 상호 작용을 중지
2. **onStop()**: Fragment가 화면에서 더이상 보여지지 않게 되며, Fragment기능이 중지 되었을때 호출
3. **onDestoryView()**: View 리소스를 해제 할수 있도록 호출, backstack을 사용 했다면 Fragment를 다시 돌아 갈때 onCreateView()가 호출

**Replace or backward로 removed되는 경우**

1. **onDestory()**: Fragment상태를 완전히 종료 할 수 있도록 호출 한다.
2. **onDetach()**: Fragment가 Activity와 연결이 완전히 끊기기 직전에 호출 된다.